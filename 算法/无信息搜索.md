---
title: æ— ä¿¡æ¯æœç´¢
date: 2020-03-07 21:59:45
tags:
    - ç®—æ³•
categories: 
    - Python
---

# DFS BFS Dijkstra

> Uninformed search, also called blind search or unguided search, is a class of general purpose search algorithms that operate in a brute-force way. The term 'uninformed' means that they have no additional information about states beyond that provides in the problem definition. These algorithms can be applied to a variety of search problems, since they don't take into account the target problem.

æœ¬æ–‡ç« å†…å®¹å‚è€ƒè‡ªBç«™upä¸»çš„è§†é¢‘é“¾æ¥å¦‚ä¸‹ğŸ‘‡

[å…¶ä¸­éƒ¨åˆ†å†…å®¹çš„åŸåˆ¶ä½œè€…é“¾æ¥](https://www.bilibili.com/video/av25761720/?spm_id_from=333.788.videocard.1)

ç»™å®šä¸€ä¸ªæ— å‘å›¾

![](https://figure-bed-y.oss-cn-beijing.aliyuncs.com/img/20200622145426.png)

## é¢„å…ˆå‡†å¤‡
```python
import queue,collections

graph={
    "A":["B","C"],
    "B":["A","C","D"],
    "C":["A","B","D","E"],
    "D":["B","C","E","F"],
    "E":["C","D"],
    "F":["D"],
}
```

## BFS

å¯ä»¥ç»“åˆæ ‘çš„å±‚åºéå†ï¼Œå›¾å…¶å®ä¹Ÿæ˜¯ä¸€æ¬¡æ€§å°†å½“å‰èŠ‚ç‚¹ç›¸è¿ä¸”æœªè®¿é—®çš„ç‚¹æ”¾å…¥é˜Ÿåˆ—ï¼Œå½“å‰èŠ‚ç‚¹åˆ™æ˜¯æ¯æ¬¡ä»é˜Ÿåˆ—å‡ºæ¥çš„ç‚¹

```python
def BFS(graph,s):
    '''
    Queue
    '''
    que=queue.Queue()
    seen=set()
    que.put(s)
    seen.add(s)
    while not que.empty():
        vertex=que.get()
        nodes=graph[vertex]
        for w in nodes:
            if w not in seen:
                que.put(w)
                seen.add(w)
        print(vertex)
```

## DFS

å°†æ ˆé¡¶èŠ‚ç‚¹çš„ç›¸é‚»èŠ‚ç‚¹æ”¾å…¥æ ˆä¸­

```python
def DFS(graph,s):
    '''
    Stack
    '''
    stack=[s]
    seen=set([s])
    while stack:
        vertix=stack.pop()
        nodes=graph[vertix]
        for w in nodes:
            if w not in seen:
                stack.append(w)
                seen.add(w)
        print(vertix)
```


## Dijkstra

è®¡ç®—graphä¸­å„ä¸ªç‚¹è·ç¦»sçš„æœ€çŸ­è·ç¦»ç®—æ³•

åŸºæœ¬ç»“æ„æ˜¯BFSï¼Œæˆ‘ä»¬å°†å½“å‰ç‚¹çš„ç›¸é‚»èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ä¸­ï¼Œä½†æ˜¯é˜Ÿåˆ—æ¯æ¬¡å¼¹å‡ºçš„å€¼è·å–æœ€å°çš„é‚£ä¸ªï¼Œå› æ­¤ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—

æ¯æ¬¡ä»é˜Ÿåˆ—å¼¹å‡ºçš„ç‚¹è‹¥ä¹‹å‰æ²¡å‡ºç°è¿‡åˆ™å…¶è·ç¦»sçš„è·ç¦»å°±æ˜¯æ‰€æœ‰è·ç¦»ä¸­æœ€çŸ­çš„

```python
graph_x={
    "A":{"B":5,"C":1},
    "B":{"A":5,"C":2,"D":1},
    "C":{"A":1,"B":2,"D":4,"E":8},
    "D":{"B":1,"C":4,"E":3,"F":6},
    "E":{"C":8,"D":3},
    "F":{"D":6},
}


def dijkstra(graph,s):
    pqueue=queue.PriorityQueue()
    node=collections.namedtuple("node","val name")
    pqueue.put(node(0,s))
    distence_dic={}
    while not pqueue.empty():
        p=pqueue.get()
        distence_dic.setdefault(p.name,p.val)
        nodes=graph[p.name]
        for k,v in nodes.items():
            if k not in distence_dic.keys():
                pqueue.put(node(v+distence_dic[p.name],k))
    return distence_dic
```

```python
if __name__=="__main__":
    BFS(graph,"A")
    DFS(graph,"A")
    res=dijkstra(graph_x,"A")
    for k,v in res.items():
        print(k,v)
```